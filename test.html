<!doctype html>
<html lang="en">
  <head>
    <meta
      name="generator"
      content="HTML Tidy for HTML5 for Linux version 5.8.0"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Kanban Board</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      #preview,
      #board,
      #taskedit {
        flex-direction: column;
        gap: 2vh;
        padding: 2vh;
        width: 80%;
        margin: auto;
        background-color: #f9f9f9;
        border-radius: 8px;
        border: 1px solid #ccc;
        min-height: 80vh;
      }

      #board {
        align-items: center;
      }
      #taskedit {
        #taskidgroup {
          flex-direction: row;
          gap: 1vh;
        }
        input,
        textarea {
          padding: 1vh;
          border: 1px solid #ccc;
          width: 100%;
          box-sizing: border-box;
        }
        textarea {
          height: 50vh;
        }

        input:hover,
        textarea:hover {
          border-color: #888;
        }

        /* Optional: Focus effect */
        input:focus,
        textarea:focus {
          outline: none;
          border-color: #007bff;
        }
      }

      body {
        height: 100%;
      }
      .kanban-container {
        display: flex;
        justify-content: space-between;
        gap: 1vh;
        width: 100%;
      }

      .kanban-column {
        background-color: #fff;
        width: 30%;
        padding: 2vh;
        border-radius: 5px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        min-height: 80vh;
      }

      .column-title {
        font-size: 1.5em;
        margin-bottom: 15px;
        color: #333;
        text-align: center;
      }

      .kanban-card,
      .preview-card {
        background-color: #e2e3e5;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 5px;
        box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
        cursor: pointer;
        transition: background-color 0.3s ease;
        user-select: none;
        .content {
          background-color: #f9f9f9;
          overflow: auto;
          overflow-wrap: break-word;
          word-wrap: break-word;
        }

        .description {
          font-size: 0.75em;
        }
      }

      .kanban-card:hover {
        background-color: #d0d2d6;
      }

      .kanban-card:last-child {
        margin-bottom: 0;
      }

      .kanban-column.drag-over {
        background-color: #e1f7d5;
      }
      .flex {
        display: flex;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="menu">
      <a href="#new">New task</a> <a href="#exporthtml">Export as HTML</a>
    </div>
    <!--This should be generated by the backend on /task/edit?id=... or without id-->
    <div id="taskedit" class="hidden">
      <div id="taskid" class="hidden"></div>
      <label for="tasktitle">Title</label> <input id="tasktitle" />
      <label for="taskdescr">Description</label>
      <textarea id="taskdescr"></textarea>
      <div class="buttons">
        <a id="taskeditsubmit" href="#submit">Submit</a>
        <a id="taskeditdelete" href="#delete">Delete</a>
        <a id="taskeditcancel" href="#/">Cancel</a>
      </div>
    </div>
    <div id="preview" , class="hidden">
      <div id="preview-content" class="preview-card">
        <div class="content">
          <h1 id="previewtitle"></h1>
          <div id="previewdescription" class="description"></div>
        </div>
      </div>
      <div class="buttons">
        <a id="previewedit" href="#edit">Edit</a>
        <a id="previewclose" href="#/">Close</a>
      </div>
    </div>
    <div id="board" class="flex">
      <div class="kanban-container">
        <div
          class="kanban-column"
          id="c1"
          title="To Do"
          ondrop="drop(event)"
          ondragover="allowDrop(event)"
        >
          <h2 class="column-title">To Do</h2>
        </div>
        <div
          class="kanban-column"
          id="c2"
          title="In Progress"
          ondrop="drop(event)"
          ondragover="allowDrop(event)"
        >
          <h2 class="column-title">In Progress</h2>
        </div>
        <div
          class="kanban-column"
          id="c3"
          title="Done"
          ondrop="drop(event)"
          ondragover="allowDrop(event)"
        >
          <h2 class="column-title">Done</h2>
        </div>
      </div>
    </div>
    <script>
      window.markdown = window.markdown || {};

      (function (namespace) {
        namespace.renderString = function (str) {
          str = str.replace(/[&<>"'`=]/g, function (match) {
            switch (match) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              case "'":
                return "&#39;";
              // TODO: should be markdown quote ... or we just don't allow that ...
              case "`":
                return "&#96;";
              case "=":
                return "&#61;";
              default:
                return match;
            }
          });

          str = str.replace(/^# (.*$)/gm, "<h1>$1</h1>");
          str = str.replace(/^## (.*$)/gm, "<h2>$1</h2>");
          str = str.replace(/^### (.*$)/gm, "<h3>$1</h3>");
          str = str.replace(/^#### (.*$)/gm, "<h4>$1</h4>");
          str = str.replace(/^##### (.*$)/gm, "<h5>$1</h5>");
          str = str.replace(/^###### (.*$)/gm, "<h6>$1</h6>");
          str = str.replace(/\*\*(.*)\*\*/gm, "<b>$1</b>");
          str = str.replace(/\[([^\[]+)\]\(([^)]+)\)/gm, '<a href="$2">$1</a>');
          str = str.replace(/\n/g, "<br/>");
          return str;
        };
      })(window.markdown);
    </script>
    <script>
      let columns = [];
      const board = document.getElementById("board");
      const backlog = document.getElementById("c1");

      //TODO: rename or better create a module which holds them
      // TODO: get rid of those const
      const edit = document.getElementById("taskedit");
      const view = document.getElementById("preview");
      const tie = document.getElementById("taskid");
      const tti = document.getElementById("tasktitle");
      const tde = document.getElementById("taskdescr");
      const tesubmit = document.getElementById("taskeditsubmit");
      const tedelete = document.getElementById("taskeditdelete");

      const teprevtitle = document.getElementById("previewtitle");
      const teprevdescription = document.getElementById("previewdescription");

      function hide_element(element) {
        element.classList.remove("flex");
        element.classList.add("hidden");
      }

      function show_element(element) {
        element.classList.remove("hidden");
        element.classList.add("flex");
      }

      function hideEditShowBoard() {
        hide_element(edit);
        show_element(board);
      }

      const put = function (id, title, description) {
        return {
          action: "put",
          id: id,
          title: title,
          description: description,
        };
      };

      const remove = function (id) {
        return { action: "delete", id: id };
      };

      const move = function (id, from, to) {
        return { action: "move", id: id, from: from, to: to };
      };

      // This routing needs to be replicated in the backend
      //
      // It will store events until synched, unfortunately we cannot just use localstorage due to its limitation.
      // Which means we store events locally in that until we are able to sync with the backend.
      function routing() {
        const parts = location.hash.slice(1).split("?") || "/";

        const action = parts[0] || "/";
        const id = new URLSearchParams(parts[1]).get("id");
        console.log("routing action", action, id, location.hash);

        if (action === "/") hideEditShowBoard();
        else if (action === "new") newTask(id);
        else if (action === "edit") newTask(id);
        else if (action === "submit") submit(id);
        else if (action === "delete") removeTask(id);
        else if (action === "exporthtml") exportHtml();
        else if (action === "view") viewTask(id);
      }

      function getUnsyncedEvents() {
        return JSON.parse(localStorage.getItem("events")) || [];
      }

      function sync_events(events) {
        console.log("TODO: implement indication for not synced yet");
        return events;
      }

      function storeEvent(event) {
        let events = getUnsyncedEvents();
        events.push(event);
        const cache = JSON.stringify(sync_events(events));
        localStorage.setItem("events", cache);
        return event;
      }

      function replaceElement(parent, element) {
        document.getElementById(element.id)?.remove();
        parent.appendChild(element);
      }

      function submit(id) {
        if (id === null) {
          alert("TODO: implement error indication for submit id=null");
        }
        if (id !== tie.innerHTML) {
          alert("TODO: implement id missmatch", id, tie.innerHTML);
        }

        const title = tti.value?.trim();
        const description = tde.value;

        if (title) {
          let event = put(id, title, description);
          const card = createKanbanCard(storeEvent(event));
          replaceElement(backlog, card);
        }

        location.href = "#/";
      }

      //     function applyGradient(element, colors, type = 'linear', direction = 'to right') {
      //     if (colors.length === 0) {
      //         console.error('Colors array cannot be empty');
      //         return;
      //     }
      //
      //     let gradient;
      //
      //     if (type === 'linear') {
      //         gradient = `linear-gradient(${direction}, ${colors.join(', ')})`;
      //     } else if (type === 'radial') {
      //         gradient = `radial-gradient(circle, ${colors.join(', ')})`;
      //     } else {
      //         console.error('Unsupported gradient type');
      //         return;
      //     }
      //
      //     element.style.backgroundImage = gradient;
      // }

      function createKanbanCard(
        task,
        showDescription = false,
        draggable = true,
      ) {
        const kanbanCard = document.createElement("div");

        kanbanCard.setAttribute("id", task.id);
        kanbanCard.classList.add("kanban-card");
        kanbanCard.addEventListener("click", function () {
          location.href = `#view?id=${task.id}`;
        });
        if (draggable) {
          kanbanCard.setAttribute("draggable", "true");
          kanbanCard.setAttribute("ondragstart", "drag(event)");
        }
        const content = document.createElement("div");
        content.setAttribute("id", `content-${task.id}`);
        content.classList.add("content");

        const title = document.createElement("h1");

        title.setAttribute("id", `title-${task.id}`);
        title.setAttribute("title", task.description);
        title.textContent = task.title;
        content.appendChild(title);

        const description = document.createElement("div");
        description.setAttribute("id", `description-${task.id}`);
        description.classList.add("description");
        description.innerHTML = markdown.renderString(task.description);

        if (!showDescription) description.classList.add("hidden");
        content.appendChild(description);

        kanbanCard.appendChild(content);
        return kanbanCard;
      }

      // here we should have a global state of cards state
      // id -> column

      function removeTask(id) {
        let event = remove(id);
        storeEvent(event);
        document.getElementById(id)?.remove();
        location.href = "#/";
      }

      function viewTask(id) {
        document.getElementById("previewedit").href = `#edit?id=${id}`;

        const task = document.getElementById(`title-${id}`);
        title = task.textContent;
        description = task.title;

        teprevtitle.textContent = title;
        teprevdescription.innerHTML = markdown.renderString(description);

        hide_element(board);
        hide_element(edit);
        show_element(view);
      }

      function newTask(uuid) {
        let title = "";
        let description = "";
        if (uuid === null) {
          uuid = self.crypto.randomUUID();
        } else {
          const task = document.getElementById(`title-${uuid}`);
          title = task.textContent;
          description = task.title;
        }

        tti.value = title;
        tde.value = description;

        tesubmit.href = `#submit?id=${uuid}`;
        tedelete.href = `#delete?id=${uuid}`;
        tie.innerHTML = uuid;

        hide_element(board);
        hide_element(view);
        show_element(edit);

        tti.focus();
        tti.select();
      }

      // Allow the drop event to occur
      function allowDrop(ev) {
        ev.preventDefault();
        ev.target.classList.add("drag-over");
      }

      // Handle drag event
      function drag(ev) {
        ev.dataTransfer.setData("text", ev.target.id);
        ev.dataTransfer.setData("origin", ev.target.parentElement.id);
      }

      // Handle drop event
      function drop(ev) {
        ev.preventDefault();
        const data = ev.dataTransfer.getData("text");
        const origin = ev.dataTransfer.getData("origin");
        console.log("drop", data, origin, "to", ev.target.id);
        const draggedElement = document.getElementById(data);
        ev.target.classList.remove("drag-over");

        // Prevent moving into the column header (not a valid drop target)
        if (ev.target === ev.currentTarget) {
          // Append the dragged card into the column
          ev.target.appendChild(draggedElement);
          storeEvent(move(data, origin, ev.target.id));
        }
      }

      function exportHtml() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: "text/html" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "page.html";
        link.click();
        location.href = "#/";
        // TODO: what to do with the localstorage? Should it be emptied for the case that the same name is used again? Should there be a button to remove localstorage?
      }

      document.querySelectorAll(".kanban-column").forEach((col) => {
        columns.push({ id: col.id, title: col.title });
        col.addEventListener("dragleave", (event) => {
          event.target.classList.remove("drag-over");
        });
      });

      window.addEventListener("hashchange", routing);
      window.addEventListener("load", routing);

      // tti.addEventListener("input", function () {
      //   teprevtitle.textContent = this.value;
      // });
      //
      // tde.addEventListener("input", function () {
      //   teprevdescription.innerHTML = markdown.renderString(this.value);
      // });

      getUnsyncedEvents().forEach((cc) => {
        if (cc.action === "put") replaceElement(backlog, createKanbanCard(cc));
        if (cc.action === "delete") document.getElementById(cc.id)?.remove();
        if (cc.action === "move")
          document
            .getElementById(cc.to)
            .appendChild(document.getElementById(cc.id));
      });
    </script>
  </body>
</html>

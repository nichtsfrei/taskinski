<!doctype html>
<html lang="en">
  <head>
    <meta
      name="generator"
      content="HTML Tidy for HTML5 for Linux version 5.8.0"
    />
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Kanban Board</title>
    <style>
      :root {
        --bg-color-top: #eff2f2;
        --bg-color-down: #f9f2f8;
        --bg-color-content: #f5e3f7;
        --bg-color-content-box: #f4f4f4; /* cards or edit dialogs, that kind of stuff */
        --acent-color: #0ee3f7; /* bords and stuff */
        --text-color: #000;
        --card-background: rgba(255, 255, 255, 0.53);
        --card-shadow: rgba(0, 0, 0, 0.1);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-size: clamp(1rem, 2vw, 2rem);
      }

      html,
      body {
        background-image: linear-gradient(
          to bottom,
          var(--bg-color-top),
          var(--bg-color-down)
        );
        height: 100%;
      }

      #menu,
      #board,
      #taskedit {
        width: 99%;
        margin: auto;
        background-color: var(--bg-color-content);
        border-radius: 8px;
        border: 1px solid var(--acent-color);
      }

      #menu {
        padding: 0.5vh;
        gap: 0.5vh;
        margin-bottom: 0.5vh;
      }

      #board,
      #taskedit {
        gap: 2vh;
        padding: 2vh;
        width: 99%;
      }

      #taskedit {
        #taskidgroup {
          flex-direction: row;
          gap: 1vh;
        }
        input,
        textarea {
          padding: 1vh;
          border: 1px solid var(--acent-color);
          width: 100%;
          box-sizing: border-box;
        }
        textarea {
          height: 50vh;
        }

        input:hover,
        textarea:hover {
          border-color: #888;
        }

        /* Optional: Focus effect */
        input:focus,
        textarea:focus {
          outline: none;
          border-color: var(--acent-color);
        }
      }


      #board {
        align-items: center;
      }

      .container {
        /* maybe hidden would work as well? */
        overflow-x: hidden;
        display: flex;
        scroll-snap-type: x mandatory;
        width: 100%;
        <!-- justify-content: space-between; -->
        <!-- gap: 1vh; -->
      }

      /* doesn't work on ff :/*/
      <!-- .container::-webkit-scrollbar { -->
      <!--   display: none; -->
      <!-- } -->

      .column {
        scroll-snap-align: center;
        flex: 0 0 22rem;
        background-color: var(--bg-color-content-box);
        padding: 1rem;
        border-radius: 5px;
        box-shadow: 0 2px 10px var(--acent-color);
        min-height: 80vh;
        margin: 0.5rem;
      }

      .column-title {
        font-size: 1.5em;
        margin-bottom: 15px;
        color: #333;
        text-align: center;
      }

      .card {
        background: var(--card-background);
        border-radius: 16px;
        box-shadow: 0 4px 30px var(--card-shadow);
        backdrop-filter: blur(3.7px);
        -webkit-backdrop-filter: blur(3.7px);
        border: 1px solid var(--bg-color-top);

        padding: 10px;
        margin-bottom: 10px;
        cursor: pointer;
        user-select: none;
        .content {
          overflow: auto;
          overflow-wrap: break-word;
          word-wrap: break-word;
        }
      }

      <!-- .column details[open] { -->
      <!--   width: 90vw; -->
      <!-- } -->

      .card:hover {
        background-color: var(--card-shadow);
      }

      .card:last-child {
        margin-bottom: 0;
      }

      .column.drag-over {
        background-color: var(--card-shadow);
      }
      .flex {
        display: flex;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="menu" , class="menu">
      <a href="#new">New task</a> <a href="#exporthtml">Export as HTML</a>
    </div>
    <div id="canvas">
      <!--This should be generated by the backend on /task/edit?id=... or without id-->
      <div id="taskedit" class="hidden">
        <div id="taskid" class="hidden"></div>
        <label for="tasktitle">Title</label> <input id="tasktitle" />
        <label for="taskdescr">Description</label>
        <textarea id="taskdescr"></textarea>
        <div class="buttons">
          <a id="taskeditsubmit" href="#submit">Submit</a>
          <a id="taskeditdelete" href="#delete">Delete</a>
          <a id="taskeditcancel" href="#/">Cancel</a>
        </div>
      </div>
      <div id="board" class="flex">
        <div id="container" class="container">
          <div
            class="column"
            id="c1"
            title="To Do"
            ondrop="drop(event)"
            ondragover="allowDrop(event)"
          >
            <h2 class="column-title">To Do</h2>
          </div>
          <div
            class="column"
            id="c2"
            title="In Progress"
            ondrop="drop(event)"
            ondragover="allowDrop(event)"
          >
            <h2 class="column-title">In Progress</h2>
          </div>
          <div
            class="column"
            id="c3"
            title="Done"
            ondrop="drop(event)"
            ondragover="allowDrop(event)"
          >
            <h2 class="column-title">Done</h2>
          </div>
          <div
            class="column"
            id="c4"
            title="Extra"
            ondrop="drop(event)"
            ondragover="allowDrop(event)"
          >
            <h2 class="column-title">4th</h2>
          </div>
        </div>
      </div>
    </div>

    <script>
      // TODO: replace with a script?
      window.markdown = window.markdown || {};

      (function (namespace) {
        namespace.renderString = function (str) {
          str = str.replace(/[&<>"'`=]/g, function (match) {
            switch (match) {
              case "&":
                return "&amp;";
              case "<":
                return "&lt;";
              case ">":
                return "&gt;";
              case '"':
                return "&quot;";
              case "'":
                return "&#39;";
              // TODO: should be markdown quote ... or we just don't allow that ...
              case "`":
                return "&#96;";
              case "=":
                return "&#61;";
              default:
                return match;
            }
          });

          str = str.replace(/^# (.*$)/gm, "<h1>$1</h1>");
          str = str.replace(/^## (.*$)/gm, "<h2>$1</h2>");
          str = str.replace(/^### (.*$)/gm, "<h3>$1</h3>");
          str = str.replace(/^#### (.*$)/gm, "<h4>$1</h4>");
          str = str.replace(/^##### (.*$)/gm, "<h5>$1</h5>");
          str = str.replace(/^###### (.*$)/gm, "<h6>$1</h6>");
          str = str.replace(/\*\*(.*)\*\*/gm, "<b>$1</b>");
          str = str.replace(/\[([^\[]+)\]\(([^)]+)\)/gm, '<a href="$2">$1</a>');
          str = str.replace(/\n/g, "<br/>");
          return str;
        };
      })(window.markdown);
    </script>
    <script>
      let columns = [];
      const board = document.getElementById("board");
      const backlog = document.getElementById("c1");

      //TODO: rename or better create a module which holds them
      // TODO: get rid of those const
      const edit = document.getElementById("taskedit");
      const tie = document.getElementById("taskid");
      const tti = document.getElementById("tasktitle");
      const tde = document.getElementById("taskdescr");
      const tesubmit = document.getElementById("taskeditsubmit");
      const tedelete = document.getElementById("taskeditdelete");

      function hide_element(element) {
        element.classList.remove("flex");
        element.classList.add("hidden");
      }

      function show_element(element) {
        element.classList.remove("hidden");
        element.classList.add("flex");
      }

      function hideEditShowBoard() {
        hide_element(edit);
        show_element(board);
      }

      const put = function (id, title, description) {
        return {
          action: "put",
          id: id,
          title: title,
          description: description,
        };
      };

      const remove = function (id) {
        return { action: "delete", id: id };
      };

      const move = function (id, from, to) {
        return { action: "move", id: id, from: from, to: to };
      };

      // This routing needs to be replicated in the backend
      //
      // It will store events until synched, unfortunately we cannot just use localstorage due to its limitation.
      // Which means we store events locally in that until we are able to sync with the backend.
      function routing() {
        const parts = location.hash.slice(1).split("?") || "/";

        const action = parts[0] || "/";
        const id = new URLSearchParams(parts[1]).get("id");
        console.log("routing action", action, id, location.hash);

        if (action === "/") hideEditShowBoard();
        else if (action === "new") newTask(id);
        else if (action === "edit") newTask(id);
        else if (action === "submit") submit(id);
        else if (action === "delete") removeTask(id);
        else if (action === "exporthtml") exportHtml();
      }

      function getUnsyncedEvents() {
        return JSON.parse(localStorage.getItem("events")) || [];
      }

      function sync_events(events) {
        console.log("TODO: implement indication for not synced yet");
        return events;
      }

      function storeEvent(event) {
        let events = getUnsyncedEvents();
        events.push(event);
        const cache = JSON.stringify(sync_events(events));
        localStorage.setItem("events", cache);
        return event;
      }

      function replaceElement(parent, element) {
        document.getElementById(element.id)?.remove();
        parent.appendChild(element);
      }

      function submit(id) {
        if (id === null) {
          alert("TODO: implement error indication for submit id=null");
        }
        if (id !== tie.innerHTML) {
          alert("TODO: implement id missmatch", id, tie.innerHTML);
        }

        const title = tti.value?.trim();
        const description = tde.value;

        if (title) {
          let event = put(id, title, description);
          const card = newTaskCard(storeEvent(event));
          replaceElement(backlog, card);
        }

        location.href = "#/";
      }

      //     function applyGradient(element, colors, type = 'linear', direction = 'to right') {
      //     if (colors.length === 0) {
      //         console.error('Colors array cannot be empty');
      //         return;
      //     }
      //
      //     let gradient;
      //
      //     if (type === 'linear') {
      //         gradient = `linear-gradient(${direction}, ${colors.join(', ')})`;
      //     } else if (type === 'radial') {
      //         gradient = `radial-gradient(circle, ${colors.join(', ')})`;
      //     } else {
      //         console.error('Unsupported gradient type');
      //         return;
      //     }
      //
      //     element.style.backgroundImage = gradient;
      // }

      function newTaskCard(task, showDescription = false, draggable = true) {
        const card = document.createElement("details");

        card.setAttribute("id", task.id);
        card.classList.add("card");
        card.setAttribute("description", task.description);
        card.setAttribute("title", task.title);

        if (draggable) {
          card.setAttribute("draggable", "true");
          card.setAttribute("ondragstart", "drag(event)");
        }

        const summary = document.createElement("summary");
        summary.textContent = task.title;
        card.appendChild(summary);
        const content = document.createElement("div");
        const menu = document.createElement("div");
        card.classList.add("menu");

        const edit = document.createElement("a");
        edit.setAttribute("href", `#edit?id=${task.id}`);
        edit.textContent = "Edit";

        menu.appendChild(edit);
        content.appendChild(menu);

        const description = document.createElement("div");
        description.innerHTML = markdown.renderString(task.description);
        content.appendChild(description);

        card.appendChild(content);

        return card;
      }

      // here we should have a global state of cards state
      // id -> column

      function removeTask(id) {
        let event = remove(id);
        storeEvent(event);
        document.getElementById(id)?.remove();
        location.href = "#/";
      }

      function newTask(uuid) {
        let title = "";
        let description = "";
        if (uuid === null) {
          uuid = self.crypto.randomUUID();
        } else {
          const task = document.getElementById(`${uuid}`);
          title = task.title;

          description = task.getAttribute("description");
        }

        tti.value = title;
        tde.value = description;

        tesubmit.href = `#submit?id=${uuid}`;
        tedelete.href = `#delete?id=${uuid}`;
        tie.innerHTML = uuid;

        hide_element(board);
        show_element(edit);

        tti.focus();
        tti.select();
      }

      // Allow the drop event to occur
      function allowDrop(ev) {
        ev.preventDefault();
        ev.target.classList.add("drag-over");
        ev.target.scrollIntoView({
          behavior: "smooth",
          block: "center",
          inline: "center",
        });
      }

      // Handle drag event
      function drag(ev) {
        ev.dataTransfer.setData("text", ev.target.id);
        ev.dataTransfer.setData("origin", ev.target.parentElement.id);
      }

      // Handle drop event
      function drop(ev) {
        ev.preventDefault();
        const data = ev.dataTransfer.getData("text");
        const origin = ev.dataTransfer.getData("origin");
        console.log("drop", data, origin, "to", ev.target.id);
        const draggedElement = document.getElementById(data);
        ev.target.classList.remove("drag-over");

        // Prevent moving into the column header (not a valid drop target)
        if (ev.target === ev.currentTarget) {
          // Append the dragged card into the column
          ev.target.appendChild(draggedElement);
          storeEvent(move(data, origin, ev.target.id));
        }
      }

      function exportHtml() {
        const htmlContent = document.documentElement.outerHTML;
        const blob = new Blob([htmlContent], { type: "text/html" });
        const link = document.createElement("a");
        link.href = URL.createObjectURL(blob);
        link.download = "page.html";
        link.click();
        location.href = "#/";
        // TODO: what to do with the localstorage? Should it be emptied for the case that the same name is used again? Should there be a button to remove localstorage?
      }

      let touchStartX = 0;
      let touchEndX = 0;

      function scrollToNextElement(element, direction) {
        const d = 500 * direction;

        document
          .getElementById("container")
          .scrollBy({ left: d, behavior: "smooth" });
      }

      document.querySelectorAll(".column").forEach((col) => {
        columns.push({ id: col.id, title: col.title });
        col.addEventListener("click", (ev) => {
          ev.target.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "center",
          });
        });
        col.addEventListener(
          "touchstart",
          (ev) => {
            console.log("touchstart", ev);
            touchStartX = ev.touches[0].clientX;
          },
          { passive: true },
        );
        container.addEventListener(
          "touchmove",
          (ev) => {
            console.log("touchmove", ev);
            touchEndX = event.touches[0].clientX;
          },
          { passive: true },
        );

        col.addEventListener(
          "touchend",
          (ev) => {
            console.log("touchend", ev);
            if (touchStartX - touchEndX > 50) {
              scrollToNextElement(event.target, -1);
            } else if (touchEndX - touchStartX > 50) {
              scrollToNextElement(event.target, 1);
            }
          },
          { passive: true },
        );

        col.addEventListener("touchstart", (ev) => {
          ev.target.scrollIntoView({
            behavior: "smooth",
            block: "center",
            inline: "center",
          });
        });

        col.addEventListener("dragleave", (event) => {
          event.target.classList.remove("drag-over");
        });
      });

      window.addEventListener("hashchange", routing);
      window.addEventListener("load", routing);

      // tti.addEventListener("input", function () {
      //   teprevtitle.textContent = this.value;
      // });
      //
      // tde.addEventListener("input", function () {
      //   teprevdescription.innerHTML = markdown.renderString(this.value);
      // });

      getUnsyncedEvents().forEach((cc) => {
        if (cc.action === "put") replaceElement(backlog, newTaskCard(cc));
        if (cc.action === "delete") document.getElementById(cc.id)?.remove();
        if (cc.action === "move")
          document
            .getElementById(cc.to)
            .appendChild(document.getElementById(cc.id));
      });
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Kanban Board</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    #board, #taskedit {
      flex-direction: column;
      gap: 2vh;
      padding: 2vh;
      width: 80%;
      margin: auto;
      background-color: #f9f9f9;
      border-radius: 8px;
      border: 1px solid #ccc;
      min-height: 80vh;
    }

    #board {
      align-items: center;
    }
    #taskedit{
      
      #taskidgroup {
          flex-direction: row;
          gap: 1vh;
      }
      input, textarea {
          padding: 1vh;
          border: 1px solid #ccc;
          width: 100%;
          box-sizing: border-box;
      }
      textarea {
        height: 50vh;
      }

      input:hover, textarea:hover {
          border-color: #888;
      }

      /* Optional: Focus effect */
      input:focus, textarea:focus {
          outline: none;
          border-color: #007BFF;
      }

    }

    body {
      height: 100%;
    }
    .kanban-container {
      display: flex;
      justify-content: space-between;
      gap: 1vh;
      width: 100%;
    }

    .kanban-column {
      background-color: #fff;
      width: 30%;
      padding: 2vh;
      border-radius: 5px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      min-height: 80vh;
    }

    .column-title {
      font-size: 1.5em;
      margin-bottom: 15px;
      color: #333;
      text-align: center;
    }

    .kanban-card {
      background-color: #e2e3e5;
      padding: 10px;
      margin-bottom: 10px;
      border-radius: 5px;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      transition: background-color 0.3s ease;
      user-select: none;
    }

    .kanban-card:hover {
      background-color: #d0d2d6;
    }

    .kanban-card:last-child {
      margin-bottom: 0;
    }

    .kanban-column.drag-over {
      background-color: #e1f7d5;
    }
     .flex{
      display: flex;
    }
   
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div id="menu">
     <a href="#new">New task</a>
     <a href="#exporthtml">Export as HTML</a>
  </div>
  <!--This should be generated by the backend on /task/edit?id=... or without id-->
  <div id="taskedit", class="hidden">
      <div id="taskidgroup" class="hidden">
        <label for="taskid">ID:</label>
        <div id="taskid"></div>
      </div>
      <label for="tasktitle">Title</label>
      <input id="tasktitle"></input>
      <label for="taskdescr">Description</label>
      <textarea id="taskdescr"></textarea>
      <div class="buttons">
         <a id="taskeditsubmit" href="#submit">Submit</a>
         <a id="taskeditdelete" href="#delete">Delete</a>
      </div>
  </div>

  <div id="board", class="flex">
    <div class="kanban-container">
        <div class="kanban-column" id="c1" ondrop="drop(event)" ondragover="allowDrop(event)">
          <h2 class="column-title">To Do</h2>
          <!-- Those should be styled anchor -->
          <div class="kanban-card" draggable="true" id="task1" ondragstart="drag(event)">Task 1</div>
          <div class="kanban-card" draggable="true" id="task2" ondragstart="drag(event)">Task 2</div>
        </div>

        <div class="kanban-column" id="c2" ondrop="drop(event)" ondragover="allowDrop(event)">
          <h2 class="column-title">In Progress</h2>
          <div class="kanban-card" draggable="true" id="task3" ondragstart="drag(event)">Task 3</div>
        </div>

        <div class="kanban-column" id="c3" ondrop="drop(event)" ondragover="allowDrop(event)">
          <h2 class="column-title">Done</h2>
          <div class="kanban-card" draggable="true" id="task4" ondragstart="drag(event)">Task 4</div>
        </div>
    </div>
  </div>

<script>
  // Create a global namespace `abs` if it doesn't exist
  window.markdown = window.markdown || {};

  (function(namespace) {
    function end(prev) {
        prev.state = 'end';
        prev.unhandled = '';
        return prev;
    }
    function end_paragraph(prev) {
        prev.content.push(`<p>${prev.unhandled}</p>`);
        return end(prev);
    }

    function countLeading(char, str) {
      let count = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === char) {
          count++;
        } else {
          break;
        }
      }
      return count;
    }
    
    function end_headline(prev) {
      const count = countLeading('#', prev.unhandled);
      const title = prev.unhandled.slice(count).trim();
      const hl = count > 6 ? 6 : count;

      prev.content.push(`<h${hl}>${title}</h${hl}>`);
      return end(prev);

    }
    namespace.renderChar = function(prev, char) {
      if (!prev) prev = {"state": "next", "unhandled": "", "content": [] };
      if (prev.state === 'end') {
        prev.state = 'next';
        return prev;
      }

      if (prev.state === 'next') {
        if (char === '#') prev.state = "begin_headline";
        else prev.state = "begin_paragraph";
      }

      if (char === '\n') {
        if (prev.state === "begin_paragraph" ) {
          return end_paragraph(prev);
        }
        if (prev.state === "begin_headline") {
          return end_headline(prev);
        }
      }
      prev.unhandled = prev.unhandled + char;
     
      return prev;
    };

    namespace.renderString = function(str) {
      let state = null;
      for (const char of str) {
        console.log("renderString", state, str, char)
        state = namespace.renderChar(state, char);
      }
      state = namespace.renderChar(state, '\n');
      console.log("state", state);
      return state.content.join('\n');
    }


  })(window.markdown);
</script>

  <script>

    const board = document.getElementById("board");
    const backlog = document.getElementById("c1");

    //TODO: rename or better create a module which holds them
    const edit = document.getElementById("taskedit");
    const tie = document.getElementById("taskid");
    const tti = document.getElementById("tasktitle");
    const tde = document.getElementById("taskdescr");
    const tesubmit = document.getElementById("taskeditsubmit");
    const tedelete = document.getElementById("taskeditdelete");

    function hide_element(element) {
      element.classList.remove("flex");
      element.classList.add("hidden");
    }

    function show_element(element) {
      element.classList.remove("hidden");
      element.classList.add("flex");
    }

    function hideEditShowBoard() {
      hide_element(edit);
      show_element(board);
    }

    const put = function(id, title, description) {
        return {"action": "put", "id": id, "title": title, "description": description};
    };
    const move = function(id, from, to) {
        return {"action": "move", "id": id, "from": from, "to": to};
    };

    // This routing needs to be replicated in the backend
    //
    // It will store events until synched, unfortunately we cannot just use localstorage due to its limitation.
    // Which means we store events locally in that until we are able to sync with the backend.
    function routing(){
      const parts = location.hash.slice(1).split('?') || '/';

      const action = parts[0] || '/';
      const id = new URLSearchParams(parts[1]).get('id');
      console.log("routing action", action, id, location.hash);

      if (action === '/') hideEditShowBoard(); 
      else if (action === 'new') newTask(null);
      else if (action === 'submit') submit(id);
      else if (action === 'delete') alert("TODO: delete");
      else if (action === 'exporthtml') exportHtml();

    }

    function getUnsyncedEvents() {
      return JSON.parse(localStorage.getItem('events')) || [];
    }


    function sync_events (events) {
      console.log("TODO: implement indication for not synced yet");
      return events;
    }

    function storeEvent(event) {

      let events = getUnsyncedEvents();
      events.push(event);
      const cache = JSON.stringify(sync_events(events));
      console.log("caching", cache);
      localStorage.setItem('events', cache);
      return event;
    }

    function submit(id) {
      if (id === null) {
        alert("TODO: implement error indication for submit id=null");
      }
      if (id !== tie.innerHTML) {
        alert("TODO: implement id missmatch", id, tie.innerHTML);
      }
      
      const title = tti.value?.trim();
      const description = tde.value;

      if (title) {
        let event = put(id, title, description);
        const card = createKanbanCard(storeEvent(event));
        backlog.appendChild(card);
        location.href = "#/";
      }



    }

//     function applyGradient(element, colors, type = 'linear', direction = 'to right') {
//     if (colors.length === 0) {
//         console.error('Colors array cannot be empty');
//         return;
//     }
//
//     let gradient;
//
//     if (type === 'linear') {
//         gradient = `linear-gradient(${direction}, ${colors.join(', ')})`;
//     } else if (type === 'radial') {
//         gradient = `radial-gradient(circle, ${colors.join(', ')})`;
//     } else {
//         console.error('Unsupported gradient type');
//         return;
//     }
//
//     element.style.backgroundImage = gradient;
// }

   function createKanbanCard(task) {
      const kanbanCard = document.createElement('div'); 
      kanbanCard.classList.add('kanban-card'); 
      kanbanCard.setAttribute('draggable', 'true'); 
      kanbanCard.setAttribute('id', task.id); 
      kanbanCard.setAttribute('ondragstart', 'drag(event)'); 
      kanbanCard.textContent = task.title; 
      const description = document.createElement('p'); 
      description.classList.add('hidden'); 
      description.textContent = task.description;
      kanbanCard.appendChild(description);
      return kanbanCard;
    }

    // here we should have a global state of cards state
    // id -> column 



    function newTask(uuid, title='', description='') {
      if (uuid === null) {
        uuid = self.crypto.randomUUID();
      }

      tti.value = title;
      tde.value = description;
      // else set title and Description found in list


      tesubmit.href = `#submit?id=${uuid}`;
      tedelete.href = `#delete?id=${uuid}`;

      tie.innerHTML = uuid;
      
      hide_element(board);
      show_element(edit);
    }

    // Allow the drop event to occur
    function allowDrop(ev) {
      ev.preventDefault();
      ev.target.classList.add('drag-over');
    }

    // Handle drag event
    function drag(ev) {
      ev.dataTransfer.setData("text", ev.target.id);
      ev.dataTransfer.setData("origin", ev.target.parentElement.id);
    }

    // Handle drop event
    function drop(ev) {
      ev.preventDefault();
      const data = ev.dataTransfer.getData("text");
      const origin = ev.dataTransfer.getData("origin");
      console.log("drop", data, origin, "to", ev.target.id);
      const draggedElement = document.getElementById(data);
      ev.target.classList.remove('drag-over');

      // Prevent moving into the column header (not a valid drop target)
      if (ev.target === ev.currentTarget) {
        // Append the dragged card into the column
        ev.target.appendChild(draggedElement);
        storeEvent(move(data, origin, ev.target.id));
      }
    }


    function exportHtml() {
      const htmlContent = document.documentElement.outerHTML;
      const blob = new Blob([htmlContent], { type: 'text/html' });
      const link = document.createElement('a');
      link.href = URL.createObjectURL(blob);
      link.download = 'page.html';
      link.click();
      location.href = "#/";
    }

    // Make sure that cards can be dropped into valid areas (columns only)
    document.querySelectorAll('.kanban-column').forEach(col => {
      col.addEventListener('dragleave', (event) => {
        event.target.classList.remove('drag-over');
      });
    });

    window.addEventListener('hashchange', routing);
    window.addEventListener('load', routing);
    tde.addEventListener('input', function () {
      onCharacterTyped(this.value);
    });

    function onCharacterTyped(currentText) {
      console.log(markdown.renderString(currentText));
      // Add your logic here
    }
    getUnsyncedEvents().forEach(cc => {
      if (cc.action === 'put') backlog.appendChild(createKanbanCard(cc));
      if (cc.action === 'move') document.getElementById(cc.to).appendChild(document.getElementById(cc.id));
    })

  </script>

</body>
</html>

